-- Create table to store email sessions (addresses generated by users)
CREATE TABLE public.email_sessions (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  session_id TEXT NOT NULL, -- Browser session identifier (for non-logged-in users)
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE, -- Null for anonymous users
  email_address TEXT NOT NULL,
  mail_tm_token TEXT NOT NULL, -- Token to access Mail.tm API
  mail_tm_account_id TEXT NOT NULL,
  mail_tm_password TEXT NOT NULL, -- Needed for re-authentication
  is_active BOOLEAN NOT NULL DEFAULT true, -- Currently active email
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL, -- Calculated based on plan (24h free, 7 days pro)
  UNIQUE(session_id, email_address)
);

-- Create table to cache messages for offline access within retention period
CREATE TABLE public.email_messages (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  email_session_id UUID NOT NULL REFERENCES public.email_sessions(id) ON DELETE CASCADE,
  mail_tm_message_id TEXT NOT NULL,
  from_address TEXT NOT NULL,
  from_name TEXT,
  subject TEXT NOT NULL,
  intro TEXT,
  text_content TEXT,
  html_content TEXT,
  is_seen BOOLEAN NOT NULL DEFAULT false,
  received_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  UNIQUE(email_session_id, mail_tm_message_id)
);

-- Enable Row Level Security
ALTER TABLE public.email_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.email_messages ENABLE ROW LEVEL SECURITY;

-- RLS Policies for email_sessions
-- Users can view their own sessions (by user_id or session_id for anonymous)
CREATE POLICY "Users can view own email sessions"
ON public.email_sessions
FOR SELECT
USING (
  user_id = auth.uid() 
  OR (user_id IS NULL AND session_id = current_setting('app.session_id', true))
);

CREATE POLICY "Users can insert own email sessions"
ON public.email_sessions
FOR INSERT
WITH CHECK (
  user_id = auth.uid() 
  OR (user_id IS NULL AND session_id = current_setting('app.session_id', true))
);

CREATE POLICY "Users can update own email sessions"
ON public.email_sessions
FOR UPDATE
USING (
  user_id = auth.uid() 
  OR (user_id IS NULL AND session_id = current_setting('app.session_id', true))
);

CREATE POLICY "Users can delete own email sessions"
ON public.email_sessions
FOR DELETE
USING (
  user_id = auth.uid() 
  OR (user_id IS NULL AND session_id = current_setting('app.session_id', true))
);

-- RLS Policies for email_messages (inherit from sessions)
CREATE POLICY "Users can view own messages"
ON public.email_messages
FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM public.email_sessions es
    WHERE es.id = email_session_id
    AND (es.user_id = auth.uid() OR (es.user_id IS NULL AND es.session_id = current_setting('app.session_id', true)))
  )
);

CREATE POLICY "Users can insert own messages"
ON public.email_messages
FOR INSERT
WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.email_sessions es
    WHERE es.id = email_session_id
    AND (es.user_id = auth.uid() OR (es.user_id IS NULL AND es.session_id = current_setting('app.session_id', true)))
  )
);

CREATE POLICY "Users can update own messages"
ON public.email_messages
FOR UPDATE
USING (
  EXISTS (
    SELECT 1 FROM public.email_sessions es
    WHERE es.id = email_session_id
    AND (es.user_id = auth.uid() OR (es.user_id IS NULL AND es.session_id = current_setting('app.session_id', true)))
  )
);

CREATE POLICY "Users can delete own messages"
ON public.email_messages
FOR DELETE
USING (
  EXISTS (
    SELECT 1 FROM public.email_sessions es
    WHERE es.id = email_session_id
    AND (es.user_id = auth.uid() OR (es.user_id IS NULL AND es.session_id = current_setting('app.session_id', true)))
  )
);

-- Create indexes for performance
CREATE INDEX idx_email_sessions_session_id ON public.email_sessions(session_id);
CREATE INDEX idx_email_sessions_user_id ON public.email_sessions(user_id);
CREATE INDEX idx_email_sessions_expires_at ON public.email_sessions(expires_at);
CREATE INDEX idx_email_sessions_is_active ON public.email_sessions(is_active);
CREATE INDEX idx_email_messages_session_id ON public.email_messages(email_session_id);

-- Function to calculate retention expiry based on user's pro status
CREATE OR REPLACE FUNCTION public.calculate_retention_expiry(p_user_id UUID)
RETURNS TIMESTAMP WITH TIME ZONE
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  is_pro BOOLEAN;
BEGIN
  -- Check if user is pro (null user_id means anonymous = free)
  IF p_user_id IS NULL THEN
    is_pro := false;
  ELSE
    SELECT COALESCE(p.is_pro, false) INTO is_pro
    FROM public.profiles p
    WHERE p.user_id = p_user_id;
  END IF;
  
  -- Pro users get 7 days, free users get 24 hours
  IF is_pro THEN
    RETURN now() + INTERVAL '7 days';
  ELSE
    RETURN now() + INTERVAL '24 hours';
  END IF;
END;
$$;

-- Function to extend retention when user upgrades to pro
CREATE OR REPLACE FUNCTION public.extend_retention_on_upgrade()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- If user just became pro, extend all their email sessions to 7 days from now
  IF NEW.is_pro = true AND (OLD.is_pro = false OR OLD.is_pro IS NULL) THEN
    UPDATE public.email_sessions
    SET expires_at = now() + INTERVAL '7 days'
    WHERE user_id = NEW.user_id
    AND expires_at > now(); -- Only extend sessions that haven't expired yet
  END IF;
  
  RETURN NEW;
END;
$$;

-- Trigger to auto-extend retention on pro upgrade
CREATE TRIGGER on_profile_pro_upgrade
  AFTER UPDATE OF is_pro ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.extend_retention_on_upgrade();

-- Function to clean up expired sessions (called by cron)
CREATE OR REPLACE FUNCTION public.cleanup_expired_sessions()
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete expired sessions (cascade deletes messages too)
  DELETE FROM public.email_sessions
  WHERE expires_at < now();
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  
  RETURN deleted_count;
END;
$$;